#!/usr/bin/python3
import os
import requests
import argparse
import getpass
import logging
from pathlib import Path
from pathlib import PurePath
from datetime import datetime

HEADERS = {'cache-control': 'no-cache',
           'Accept': 'application/json'}

parser = argparse.ArgumentParser(formatter_class=argparse.RawTextHelpFormatter, description='''\
Red Hat bulk upload module for Pantheon 2. This tool will scan a directory recursively and upload relevant files.

Both this uploader and Pantheon 2 are ALPHA software and features may update or change over time. 
 
''')
parser.add_argument('--server', '-s', help='The Pantheon server to upload modules to, default http://localhost:8080', default='http://localhost:8080')
parser.add_argument('--repository', '-r', help='The name of the repository; this is a convenience for the user. If not specified, one will be autogenerated', default=getpass.getuser() + '_' + datetime.now().strftime('%Y-%m-%d_%H-%M-%S'))
parser.add_argument('--user', '-u', help='Username for authentication, default \'demo\'', default='demo')
parser.add_argument('--password', '-p', help='Password for authentication, default \'demo\'. If \'-\' is supplied, the script will prompt for the password.', default='demo')
parser.add_argument('--directory', '-d', help='Directory to upload, default is current working directory. (' + os.getcwd() + ')', default=os.getcwd())
parser.add_argument('--log', '-l', help='Verbosity of logging, default is \'warning\'', default='warning')
args = parser.parse_args()

numeric_level = getattr(logging, args.log.upper(), None)
if not isinstance(numeric_level, int):
    raise ValueError('Invalid log level: %s' % args.log)
logger = logging.getLogger(__name__)
logger.setLevel(numeric_level)
logger.addHandler(logging.StreamHandler())

pw = args.password
if pw == '-':
    pw = getpass.getpass()

print('Using server: ' + args.server)
print('Using repository: ' + args.repository)
print('--------------')

pathlist = Path(args.directory).glob('**/*')

for path in pathlist:
    base_name = path.stem

    ppath = path
    hiddenFolder = False
    while not ppath == PurePath(args.directory):
        logger.debug('ppath: %s', str(ppath.stem))
        if ppath.stem[0] == '.':
            hiddenFolder = True
            break
        ppath = ppath.parent
    if hiddenFolder:
        logger.info('Skipping %s because it is hidden.', str(path))
        continue

    if not path.is_file():
        logger.info('Skipping %s because it is not a file.', str(path))
        continue

    # parent directory
    parent_dir_str = str(path.parent.relative_to(args.directory))
    if parent_dir_str == '.':
        parent_dir_str = ''
    logger.debug('parent_dir_str: %s', parent_dir_str)
    # file becomes a/file/name (no extension)

    url = args.server + "/content/repositories/" + args.repository
    if parent_dir_str:
        url += '/' + parent_dir_str

    logger.debug('base name: %s', base_name)

    # Asciidoc content (treat as a module)
    if path.suffix == '.adoc' or path.suffix == '.asciidoc':
        print(path)
        url += '/' + path.name
        logger.debug(url)
        data = {"jcr:primaryType": 'pant:module',
                "jcr:title": base_name,
                "jcr:description": base_name,
                "sling:resourceType": 'pantheon/modules',
                "pant:originalName": path.name,
                "asciidoc@TypeHint": 'nt:file'}
        files = {'asciidoc': ('asciidoc', open(path, 'rb'), 'text/x-asciidoc')}

        # Minor question: which is correct, text/asciidoc or text/x-asciidoc?
        # It is text/x-asciidoc. Here's why:
        # https://tools.ietf.org/html/rfc2045#section-6.3
        # Paraphrased: "If it's not an IANA standard, use the 'x-' prefix.
        # Here's the list of standards; text/asciidoc isn't in it.
        # https://www.iana.org/assignments/media-types/media-types.xhtml#text

        r = requests.post(url, headers=HEADERS, data=data, files=files, auth=(args.user, pw))
        print(r.status_code, r.reason)
        print()
    # Otherwise just upload as a regular file
    else:
        print(path)
        logger.debug(url)
        files = {path.name: (path.name, open(path, 'rb'))}
        r = requests.post(url, headers=HEADERS, files=files, auth=(args.user, pw))
        print(r.status_code, r.reason)
        print()

print('Finished!')
